# Textbooks
- Computer Systems: A Programmer's Perspective, Third Edition (cs:app3e) Pearson,2016
- http://csapp.cs.cmu.edu/
- The C Programming Language, Second Edition, Prentice Hall, 1988

I think a  really good strategy for studying and preparing for this course would be to **read each chapter three times**

# Aim

- 了解编译系统

  - **优化程序性能**

    比如：

    1. 一个switch语句是否总是比一系列的if-else语句高效的多？
    2. 一个函数调用的开销有多大？
    3. while循环比for循环更有效吗?
    4. 指针引用比数组索引更有效吗？
    5. 为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用索引传递过来的参数中，运行起来快很多呢？
    6. 为什么我们只是简单的重新排列一下算术表达式的括号就能让函数运行的更快？

  - 理解链接时出现的错误

    1. 连接器报告说它无法解析一个引用，这是什么意思
    2. 静态变量和全局变量的区别是什么？
    3. 如果你在不同的C文件中定义了名字相同的两个全局变量会发生什么？
    4. **静态库和动态 库的区别是什么？**
    5. 我们在命令行上排列库的顺序有什么影响？
    6. 为什么有些链接错误直到运行时才会出现

  - 避免安全漏洞。 常见的漏洞攻击: 缓冲区溢出攻击


# 第一周(chapter I)

**计算需要先有菜谱，然后有执行步骤，最后有数据结构与算法，最后才是实现**

信息就是位+上下文

源程序就是一个由值0和1组成的位(又成bit比特)，8位被组织成一组，称为字节byte

> 一定要理解bit和byte的关系，最高有效**byte**字节包含bit[x<sub>w-1</sub>,x<sub>w-2</sub>x<sub>w-3</sub> ….. x<sub>w-8</sub>], 最低有效字节包含位[x<sub>7</sub>, x<sub>6</sub>, …., x<sub>0</sub>]

上下文context: 操作系统保持追踪进程运行所需的所有状态信息. 包括许多信息,比如PC和寄存器文件的当前值,以及主存的内容.

在任何一个时刻,单处理器系统都只能执行一个进程的代码,当操作系统决定要把控制权从当前进程转移到某个新进程时,就会进行**上下文切换context switch** 即保存当前进程的上下文,恢复新进程的上下文,然后将控制权传递到新进程.

示例场景中有两个并发的进程,shell进程和hello进程,最开始只有shell进程在运行,即等待命令行上的输入. 当我们让它运行hello程序时,shell通过调用一个专门的函数,即**系统调用**,来执行我们的请求,系统调用会将控制权传递给操作系统, 操作系统保存shell进程的上下文,创建一个新的hell进程及其上下文,然后将控制权传给新的hello进程, hello进程终止后,操作系统恢复shell进程的上下文, 并将控制权传回给它.<sup>P12</sup>

从一个进程到另一个进程的转换是**由操作系统内核(kernel)管理的** 内核是操作系统代码常驻内存的部分. 当应用程序需要操作系统的某些操作时, 比如读写文件, 它就执行一条特殊的system call 系统调用指令,将控制权传递给内核, 然后内核执行被请求的操作并返回应用程序, 注意,内核不是一个独立的进程,相反,他是系统管理全部进程所用代码和数据结构的集合

## 进制转换

字母'a' ~ 'z' 的ASCII码为 0x61 ~ 0x7Az



## 整数和浮点数

除了最高有效位1， 整数的所有未都嵌在浮点数中。

例子:

12345的整型为0x00003039, 浮点数0x4640E400

3510593为0x00359141, 3510593.0为0x4A564504

​              0011 0101 1001 0001 0100 0001
​             001 101 0110 0100 0101 0000 01
0100 1001 0101 0110 0100 0101 0000 0100

## 布尔代数 Boolean algebra

|signal | logical operations  |
|--|--|
|~ tilde | 取反|
|& ampersand | and 与 相同为1/0 不同为0| 
|\| | OR 或 相同为0/1 不同为1|
|^ | EXCLUSIVE-OR 异或 相同为0， 不同为1|

布尔代数和整数运算有很多相似之处，具有分配律，集合律等

整数运算的一个属性是每个值x都有一个加法逆元(additive inverse)-x,  使得x+(-x)=0 

布尔代数这里的"加法"运算是^ , 也就是对于任何值a来说，这里a^a=0

应用:[除自己之外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

## 位级运算和逻辑运算，移位运算

首先要分清它们之间的优先级(按照从左至右结合性规则依次递减，!,移位>><<, &,^,|,&&,||)，如果不清楚，请**加上括号**

逻辑运算:
> 认为所有非0的参数都表示**True** 返回1/0x01, 参数0表示**flase** 返回0/0x00, <sup>P37-39</sub> 

而Golang中是不支持integer 与boolean 互相转换的

> 如果对第一个参数求值就能确定表达式的结果, 逻辑运算符就不会对第二个参数求值

应用:`a&&5/a`将不会造成被零除, p&&*p++也不会导致间接引用空指针

shift Operations:
> 从左至右结合
> 逻辑右移和算术右移的区别: 算术右移是在左端补k个最高有效位的值,即是0就补0,1就补1

