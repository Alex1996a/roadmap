使用GO语言的一个开源的,高可用的分布式key-values存储系统,可以用于配置共享,服务的注册和发现

类似的项目有zookeeper和consul

etcd具有以下特点:

- 完全复制: 集群中的每个节点都可以使用完整的存档

- 高可用性: etcd可用于避免硬件的单点故障或网络问题

- 一致性: 每次读取都会返回跨多主机的最新写入

- 简单: 包括一个定义良好,面向用户的API(grpc)

- 安全: 实现了带有可选的客户端证书身份验证的自动化LTS

- 快速: 每秒100000次写入的基准测试

- 可靠: 使用raft算法实现了强一致性,高可用的服务存储目录

  # 应用场景

  - 服务发现

  - 配置中心

    - 应用在启动的时候主动从etcd获取一次配置信息, 同时,在etcd节点上注册一个watcher并等待,以后每次配置有更新的时候,etcd都会实时通知订阅者,以此达到获取最新配置信息的目的

  - 分布式锁

    因为etcd使用Raft算法保持了数据的强一致性,所以很容易实现分布式锁. 有两种使用方式, 1. 保持独占,2. 控制时序

    - **保持独占即所有获取锁的用户最终只有一个可以得到**. etcd为此提供了一套实现分布式锁原子操作CAS(compareAndSwap)的API,通过设置`prevExist`值, 可以保证在多个节点同时去创建某个目录时,只有一个成功,而创建成功的用户就可以认为是获得了锁
    - 控制时序,即所有想要获得锁的用户都会被安排执行 , 但是**获得锁的顺序也是全局唯一的,同时决定了执行顺序**,etcd为此也提供了一套API(自动创建有序键), 对一个目录键值时指定为`POST`动作,这样etcd会自动在目录下生成一个当前最大的值为键, 存储这个新的值(客户端编号). 同时还可以使用API按顺序列出所有当前目录下的键值,此时这些key的值就是客户端的时序, 而这些key中存储的值可以是代表客户端的编号

    

  # Raft算法

  不同于Paxos算法直接从分布式一致性问题出发推导出来，Raft算法则是从多副本状态机的角度提出，用于管理多副本状态机的日志复制。Raft实现了和Paxos相同的功能，它将一致性分解为多个子问题：Leader选举（Leader election）、日志同步（Log replication）、安全性（Safety）、日志压缩（Log compaction）、成员变更（Membership change）

  

  ### 选举

  follower --> candidate -> leader

  candidate 是一个中间态, 临时态
  
  ### 日志复制机制
  
  commit  uncommit
  
  ### 异常处理(脑裂)

zookeeper的zad协议的区别