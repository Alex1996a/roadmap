贪心算法在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。

# 伪代码
```txt
从问题的某一初始解出发
  while (能朝给定总目标前进一步) 
    do
      选择当前最优解作为可行解的一个解元素；
  由所有解元素组合成问题的一个可行解。
```

### 题目描述：

小明手中有 1，5，10，50，100 五种面额的纸币，每种纸币对应张数分别为 5，2，2，3，5 张。若小明需要支付 456 元，则需要多少张纸币？

![img](https://mmbiz.qpic.cn/mmbiz_png/D67peceibeIS2h2X050odhmVhRMD46VD5n4lt8pUx4HkRCv8mI2uxycw7eG0VPRDzovEBk0FgYYlAQ0wxKibBAuw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 题目分析

（1）**建立数学模型**
  设小明每次选择纸币面额为 Xi ，需要的纸币张数为 n 张，剩余待支付金额为 V ，则有：
X1 + X2 + … + Xn = 456.
（2）**问题拆分为子问题**
  小明选择纸币进行支付的过程，可以划分为n个子问题：即每个子问题对应为：
在未超过456的前提下，在剩余的纸币中选择一张纸币。
（3）**制定贪心策略，求解子问题**

制定的贪心策略为：在允许的条件下选择面额最大的纸币。则整个求解过程如下：

- 选取面值为 100 的纸币，则 X1 = 100, V = 456 - 100 = 356；
- 继续选取面值为 100 的纸币，则 X2 = 100, V = 356 - 100 = 256；
- 继续选取面值为 100 的纸币，则 X3 = 100, V = 256 - 100 = 156；
- 继续选取面值为 100 的纸币，则 X4 = 100, V = 156 - 100 = 56；
- 选取面值为 50 的纸币，则 X5 = 50, V = 56 - 50 = 6；
- 选取面值为 5 的纸币，则 X6 = 5, V = 6 - 5 = 1；
- 选取面值为 1 的纸币，则 X7 = 1, V = 1 - 1 = 0；求解结束

（4）**将所有解元素合并为原问题的解**

小明需要支付的纸币张数为 7 张，其中面值 100 元的 4 张，50 元 1 张，5 元 1 张，1 元 1 张。

### 代码实现

```
const int N = 5; 
int Count[N] = {5,2,2,3,5};//每一张纸币的数量 
int Value[N] = {1,5,10,50,100};
int solve(int money) {
    int num = 0;
    for(int i = N-1;i>=0;i--) {
        int c = min(money/Value[i],Count[i]);//每一个所需要的张数 
        money = money-c*Value[i];
        num += c;//总张数 
    }
    if(money>0) num=-1;
    return num;
}
```