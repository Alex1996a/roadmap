# 递归

1. 找到最小子问题(即共性)
2. 确定退出条件

# 动态规划dynamic programming简称dp

1. 问题拆分小问题  [这点和递归的最小子问题差不多]
2. 建议状态转移方程 [从小到大可以转化为从大到小，从多维空间压缩到一维空间，要活用] 
3. 缓存并复用以往结果【**注意:复用**】
4. 按顺序从小到大计算

 **取决于该问题是否能用动态规划解决的是这些”小问题“会不会被被重复调用。**

-  **状态定义** 其实是需要思考在解决一个问题的时候我们做了什么事情，然后得出了什么样的答案，对于这个问题，当前问题的答案就是当前的状态，基于上面的问题拆解，你可以发现两个相邻的问题的联系其实是 `后一个问题的答案 = 前一个问题的答案 + 1`，这里，状态的每次变化就是 +1。

```python
def fib(n):
	results = list(range(n+1)) # 用于缓存以往结果,以便复用(目标2)
	for i in range(n+1): # 按顺序从小到大算(目标3)
		if i<2 :
			result[i] =i
		else:
			# 使用状态转移方程(目标1),同时复用以往结果(目标2)
			result[i] = result [i-1] + result[i+1]
	return results[-1]
if __name__ == '__main__':
    result = fib()
```

### 如何建立状态转移方程

[leetcode题解](https://leetcode-cn.com/problems/triangle/solution/go-dp-ti-jie-by-ivan1/)