进程

- 每个进程都有一个父进程
- 当子进程终止时,父进程会得到通知并能取得子进程的退出状态

命名空间--> PID, UTC

进程组

- 每个进程也属于一个进程组
- 每个进程主都有一个进程组号,改号等于该进程组组长的PID号
- 一个进程只能为它自己或子进程设置进程组ID号

进程组组长-groupleader

会话期

- 对话期(session)是一个或多个进程组的集合
- setid()函数可以建立一个对话期



# 程序application

编译好的二进制文件,在磁盘上,不占用系统资源(内存,打开的文件,设备,锁)

# 进程 programming

这是一个抽象的概念,与操作系统原理联系紧密, 进程是活跃的程序, 占用系统资源,在内存中执行,**(程序运行起来,就产生一个进程)**

- 程序-> 剧本
- 进程-> 戏 (舞台,演员, 灯光, 道具...)

同一个剧本可以在多个舞台同时上演, 同样, 同一个程序也可以**加载为不通的进程** (彼此之间互不影响)

如: 同时开两个终端, 各自都有一个bash, 但彼此ID不同.

## 进程状态/ 3或者5种

初始态, 就绪态, 运行态, 挂起态, 终止态, 其中初始态为进程准备阶段, 常与就绪状态结合来看

![image-20200507224706503](../image/image-20200507224706503.png)

![img](../image/1812253-20191013185117226-793716623.png)

![img](../image/processlife_1000.png)

window下的进程只是提供 执行环境, window下必定分配线程

# 线程 thread

最开始是window的概念,Unix/Linux是模拟出来的, 本质仍是进程

进程: 独立地址空间,拥有PCB

线程: 有独立的PCB, 但没有独立的地址空间(共享)

区别: 在于是否共享地址空间, 独居(进程); 合租(线程)



==hlighted weight process: LWP轻量级的进程,  最小的执行单位-- CPU分配时间轮片的对象==

==进程: 最小的系统资源分配单位== 可看成是只有一个线程的进程

## 线程同步

即**协同步调**,按预定的先后顺序运行

**线程同步, 指一个线程发出某一功能调用时, 在没有得到结果之前,该调用不返回,同时其他线程为保护数据一致性, 不能调用该功能**

"同步"的目的, 是为了避免数据混乱, 解决与时间有关的错误,实际上,不仅线程间需要同步, 进程间, 信号间等等都需要同步机制.

因此, 所有"多个控制流, 共同操作一个共享资源" 的情况, 都需要同步



# 锁的应用

## 互斥量Mutex

- 互斥锁

  建议锁, 拿到锁, 才能访问数据, 没有拿到锁的线程, 阻塞等待, 等到拿锁的线程释放锁

- 读写锁

  写独占,读共享, 写锁优先级高	

# 协程 coroutine

轻量级线程

一个线程可以有任意多个协程, 但**某一时刻只能有一个协程在运行, 多个协程分配线程得到的计算机资源**

==协程提高了程序执行的效率==进而节省了时间

不要直接理解为节省了时间

# 总结

在一次并发任务中,进程 线程 协程均可实现, 从系统资源消耗的角度出发看, 进程相当多,线程次之,协程最少

# Linux 下的进程管理

Linux 在启动过程中，有三个特殊的进程，也就是 PID 号最小的三个进程。

- 0 号进程为 idle 进程，这也是系统创建的第一个进程，它在初始化 1 号和 2 号进程后，演变为空闲任务。当 CPU 上没有其他任务执行时，就会运行它。

- 1 号进程为 init 进程，通常是 systemd 进程，在用户态运行，用来管理其他用户态进程。

- 2 号进程为 kthreadd 进程，在内核态运行，用来管理内核线程。

  `$ ps -f --ppid 2 -p 2`
  由于内核线程的名称[CMD] 都在中括号中，所以更简单的方法，就是直接查找名称中包含中括号的进程`ps -ef | grep "\[.*\]"`

## 内核线程的作用

1.  ksoftirqd: 它是一个用来处理软中断的内核线程，并且每个 CPU 上都有一个。遇到 ksoftirqd 的 CPU 使用高的情况，就会首先怀疑是软中断的问题，然后从软中断的角度来进一步分析
2. kswapd0：用于内存回收。kswapd0 定义了三个内存阈值（watermark，也称为水位），分别是页最小阈值（pages_min）、页低阈值（pages_low）和页高阈值（pages_high）
3. kworker：用于执行内核工作队列，分为绑定 CPU （名称格式为 kworker/CPU86330）和未绑定 CPU（名称格式kworker/uPOOL86330）两类。
4. migration：在负载均衡过程中，把进程迁移到 CPU 上。每个 CPU 都有一个 migration 内核线程。
5. jbd2/sda1-8：jbd 是 Journaling Block Device 的缩写，用来为文件系统提供日志功能，以保证数据的完整性；名称中的 sda1-8，表示磁盘分区名称和设备号。每个使用了 ext4 文件系统的磁盘分区，都会有一个 jbd2 内核线程。
6. pdflush：用于将内存中的脏页（被修改过，但还未写入磁盘的文件页）写入磁盘（已经在 3.10 中合并入了 kworker 中）。